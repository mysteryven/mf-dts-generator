{"version":3,"sources":["../src/server.ts","../src/constant.ts","../src/utils.ts","../src/websocket.ts","../src/buildType.ts","../src/moduleGraph.ts"],"sourcesContent":["import chokidar from 'chokidar';\nimport http from 'http';\nimport serveHandler from 'serve-handler';\nimport { defaultConfigFileName, MF_TYPE_DIR, SERVER_PORT, tazName } from './constant';\nimport { getTime, info, readConfig } from './utils';\nimport createWebSocketServer, { addAWebSocketClient } from './websocket';\nimport path from 'path';\nimport tar from 'tar';\nimport fs from 'fs-extra';\nimport buildType from './buildType';\nimport { debounce } from 'throttle-debounce'\nimport ModuleGraph from './moduleGraph';\nimport { MFTypeConfig } from './interface';\n\nexport default async function start(filePath: string) {\n    const options = readConfig(filePath)!\n\n    info('根据模块联邦入口构建类型...');\n    fs.ensureDir(MF_TYPE_DIR)\n    fs.emptyDirSync(MF_TYPE_DIR)\n    await Promise.all(Object.entries(options.exposes).map(([output, input]) => {\n        return buildType(input, path.join(MF_TYPE_DIR, options.name, output))\n    }))\n    compressTypes(options)\n\n    info('启动 http 下载服务');\n\n    const server = http.createServer((request, response) => {\n        return serveHandler(request, response, {\n        });\n    })\n\n    server.listen(SERVER_PORT, () => {\n    })\n\n    const notifyClientToDownload = createWebSocketServer(options)\n\n    info('5 秒后开始监听文件变化...')\n    setTimeout(async () => {\n        const paths = Array.from(new Set(Object.values(options.exposes).map(str => path.dirname(str))))\n\n        const callback = await debounceCallback(notifyClientToDownload)\n\n        info('-------------------------------------')\n        info('|**********开始监听文件变化*********|')\n        info('-------------------------------------')\n\n        chokidar.watch(paths, {\n            awaitWriteFinish: true,\n            ignored: ['**/*.d.ts', '**/*.css', '**/*.less', '**/*.scss', '**/*.js']\n        }).on('change', (...args) => {\n            info('准备重新生成[' + getTime() + ']');\n            callback(...args)\n        });\n    }, 5000)\n\n    async function debounceCallback(notifyClientToDownload: () => void) {\n        const moduleGraph = new ModuleGraph(options.alias)\n        await moduleGraph.init(Object.values(options.exposes))\n\n        return debounce(3000, async (changedPath: string, stats?: fs.Stats) => {\n            if (changedPath.endsWith('.ts') || changedPath.endsWith('.tsx')) {\n                await moduleGraph.handleModuleChange(changedPath)\n                const changedEntryPaths = moduleGraph.getUpdateFilesByModuleName(changedPath)\n                const changedExposes: Array<[string, string]> = []\n\n                for (let [key, value] of Object.entries(options.exposes)) {\n                    if (changedEntryPaths.has(value)) {\n                        changedExposes.push([key, value])\n                    }\n                }\n                if (changedExposes.length === 0) {\n                    info(`没有需要修改的文件[${getTime()}]`)\n                    return\n                }\n\n                info('根据修改，准备重新生成下面几个：')\n                for (let [key] of changedExposes) {\n                    info(`${key}`)\n                }\n                info('---')\n                try {\n                    await Promise.allSettled(changedExposes.map(([output, input]) => {\n                        return buildType(input, path.join(MF_TYPE_DIR, options.name, output))\n                    }))\n\n                    // 只在用 websocket 传输时压缩\n                    if (Array.isArray(options.targetPaths) && options.targetPaths.length > 0) {\n                        await compressTypes(options)\n                    }\n\n                    info(`重新生成完毕[${getTime()}]`);\n\n                    notifyClientToDownload()\n                } catch (e) {\n                    console.error(e)\n                }\n            } else {\n                info('没有需要生成的')\n            }\n        })\n    }\n}\n\nfunction compressTypes(options: MFTypeConfig) {\n    return tar.c(\n        {\n            file: tazName,\n            cwd: MF_TYPE_DIR\n        },\n        [options.name]\n    )\n}\n\nexport {\n    addAWebSocketClient,\n    defaultConfigFileName,\n}\n\n\n","export const WEBSOCKET_PORT = 9001\nexport const SERVER_PORT = 9000\nexport const WebSOCKET_CLIENT_DOWNLOAD_PATH = `ws://127.0.0.1:${WEBSOCKET_PORT}`\nexport const MF_TYPE_DIR = 'mf-type'\nexport const bareImportRE = /^[\\w@](?!.*:\\/\\/)/\nexport const EMPTY_PATH = '';\nexport const tazName = 'my-tarball.tgz'\nexport const defaultConfigFileName = 'mf.config.js'\n","import pc, { green } from 'picocolors'\nimport fs from 'fs'\nimport path from 'path'\nimport { MFTypeConfig } from './interface';\n\nexport function success(str: string) {\n    console.log(green(pc.bold(str)));\n}\n\nexport function info(str: string) {\n    console.log(pc.dim(str))\n}\n\nexport function warn(str: string) {\n    console.log(pc.yellow(str))\n}\n\nexport function readConfig(filePath: string) {\n    const root = process.cwd()\n    if (fs.existsSync(path.join(root, filePath))) {\n        const config = require(path.join(root, filePath));\n        validateConfig(config)\n        if (!config.mfTypeConfig.clientOutDir) {\n            config.mfTypeConfig.clientOutDir = 'types'\n        }\n        if (!config.mfTypeConfig.exposes) {\n            config.mfTypeConfig.exposes = {}\n        }\n\n        if (!config.mfTypeConfig.root) {\n            config.mfTypeConfig.root = root\n        }\n\n        return config.mfTypeConfig as MFTypeConfig\n    } else {\n        throw new Error(`目录[${root}]下没有读到${filePath}文件`)\n    }\n}\n\nfunction validateConfig(config: any) {\n    const mfTypeConfig = config.mfTypeConfig\n\n    if (mfTypeConfig.clientOutDir) {\n        return\n    }\n\n    if (!mfTypeConfig.name) {\n        throw new Error('name 必填')\n    }\n\n    if (mfTypeConfig.exposes && typeof mfTypeConfig.exposes !== 'object') {\n        throw new Error('exposes 必须是对象')\n    }\n\n    if (mfTypeConfig.targetPaths && !Array.isArray(mfTypeConfig.targetPaths)) {\n        throw new Error('targetPaths 必须是数组')\n    }\n}\n\nexport function getTime() {\n    return new Date().toLocaleTimeString('default', {\n        hour: '2-digit',\n        minute: '2-digit',\n        second: '2-digit'\n    });\n}","import { WEBSOCKET_PORT, WebSOCKET_CLIENT_DOWNLOAD_PATH, MF_TYPE_DIR, SERVER_PORT, tazName } from './constant';\nimport { WebSocketServer, WebSocket } from 'ws';\nimport fs from 'fs-extra'\nimport http from 'http'\nimport path from 'path'\nimport { MessagePayload, MFTypeConfig, DownloadPayload } from './interface';\nimport tar from 'tar'\nimport { getTime, info, readConfig, warn } from './utils';\n\nexport default function createWebSocketServer(options: MFTypeConfig) {\n    const wss = new WebSocketServer({ port: WEBSOCKET_PORT });\n    wss.on('connection', function connection(ws) {\n        notifyClientToDownload()\n    });\n\n    if (Array.isArray(options.targetPaths) && options.targetPaths.length > 0) {\n        createWebSocketClient(options)\n    }\n\n\n\n    function notifyClientToDownload() {\n        wss.clients.forEach(client => {\n            if (client.readyState === WebSocket.OPEN) {\n                client.send(JSON.stringify({ type: 'download' }))\n            }\n        })\n    }\n\n    return notifyClientToDownload\n}\n\n\nexport function addAWebSocketClient(filePath: string) {\n    const config = readConfig(filePath)!;\n    createWebSocketClient(config)\n}\n\nexport function createWebSocketClient(options: MFTypeConfig) {\n    const ws = new WebSocket(WebSOCKET_CLIENT_DOWNLOAD_PATH);\n\n    ws.on('message', async function message(data) {\n        const payload = JSON.parse(data.toString());\n\n        if (isMessagePayload(payload)) {\n            info(payload.content);\n        } else if (isDownloadPayload(payload)) {\n            if (Array.isArray(options.targetPaths) && options.targetPaths.length > 0) {\n                const sourceDest = path.join(options.root, MF_TYPE_DIR);\n                if (!fs.existsSync(sourceDest)) {\n                    warn('没有找到类型文件目录' + MF_TYPE_DIR);\n                    return\n                }\n                for (let pathName of options.targetPaths) {\n                    fs.copySync(\n                        sourceDest,\n                        path.join(pathName, options.clientOutDir!)\n                    );\n                }\n                info(`类型已经拷贝好[${getTime()}]`);\n            } else {\n                const tempClientDtsFileName = path.resolve(__dirname, 'my.tar.tgz');\n                await downloadFile(tempClientDtsFileName)\n                // readConfig 的时候强制添加了，默认值是 types\n                fs.ensureDirSync(path.join(__dirname, options.clientOutDir!))\n                await tar.x({\n                    file: tempClientDtsFileName,\n                    cwd: path.join(__dirname, options.clientOutDir!)\n                })\n                info(`类型已下载好了[${getTime()}]\\n`);\n                await fs.remove(tempClientDtsFileName)\n            }\n        }\n    });\n}\n\nfunction isMessagePayload(payload: any): payload is MessagePayload {\n    return typeof payload === 'object' && payload.type === 'message';\n}\n\nfunction isDownloadPayload(payload: any): payload is DownloadPayload {\n    return typeof payload === 'object' && payload.type === 'download';\n}\n\n\nfunction downloadFile(dtsFileName: string) {\n    const url = 'http://localhost:' + SERVER_PORT + '/' + tazName;\n\n    return new Promise<boolean>((resolve) => {\n        const target = fs.createWriteStream(dtsFileName);\n\n        http.get(url, (response) => {\n            response\n                .pipe(target)\n                .on('close', () => {\n                    resolve(true)\n                })\n                .on('finish', () => {\n                    resolve(true)\n                })\n                .on('error', () => {\n                    resolve(false)\n                })\n        })\n    })\n}","import { OutputOptions, rollup, RollupBuild, RollupOptions } from 'rollup';\nimport dts from 'rollup-plugin-dts'\nimport fs from 'fs'\nimport path from 'path'\nimport esbuild from 'rollup-plugin-esbuild'\n\nexport default function buildType(input: string, output: string) {\n    if (!fs.existsSync(input)) {\n        throw new Error(`构建类型的文件 ${input} 不存在，再确认一下！`)\n    }\n\n    const inputOptions: RollupOptions = {\n        input,\n        plugins: [esbuild(), dts()]\n    };\n\n    const outputOptions: OutputOptions = {\n        file: path.join(output, 'index.d.ts'),\n        format: 'es',\n    }\n\n    return build(inputOptions, outputOptions)\n}\n\nasync function build(inputOptions: RollupOptions, outputOptions: OutputOptions) {\n    let bundle: RollupBuild | null;\n    try {\n        bundle = await rollup(inputOptions);\n        return await generateOutputs(bundle, outputOptions);\n    } catch (e) {\n        console.error('打包类型出错了，暂时中断')\n        return false\n    }\n}\n\nasync function generateOutputs(bundle: RollupBuild, outputOptions: OutputOptions) {\n    await bundle.write(outputOptions);\n\n    // 这个可以拿到最终打出来的结果，后面发现也不需要了\n    // 就先注释了\n    // let codes: string[] = []\n    // for (const chunkOrAsset of output) {\n    //     if (chunkOrAsset.type === 'chunk') {\n    //         codes.push(chunkOrAsset.code)\n    //     }\n    // }\n    // console.log('-----')\n    // console.log(codes)\n    // console.log('-----')\n\n    // return codes\n}\n\n","import { init, parse } from 'es-module-lexer'\nimport fs from 'fs-extra'\nimport path from 'path';\nimport esbulid from 'esbuild'\nimport { bareImportRE, EMPTY_PATH } from './constant';\n\nclass ModuleNode {\n    importers = new Set<string>();\n    importedModules = new Set<string>()\n}\n\nexport default class ModuleGraph {\n    fileToModuleMap = new Map<string, ModuleNode>()\n    alias: Record<string, string> = {}\n    entrys = new Set<string>()\n\n    constructor(alias?: Record<string, string>) {\n        this.alias = alias || {}\n    }\n\n    async init(entrys: string[]) {\n        this.entrys = new Set(entrys)\n        for (let entry of entrys) {\n            await this.buildImportGraph(entry)\n        }\n    }\n\n    async getImportedFileNames(filename: string) {\n        await init\n        const content = fs.readFileSync(filename, 'utf8');\n        // tsx parse 没法识别，用 esbuild 转成 保留 Import 的 语法\n        const [imports] = parse(filename.endsWith('ts') ? content : esbulid.transformSync(content, {\n            loader: 'tsx',\n            target: 'es2022',\n        }).code);\n\n        const ret = imports.map(i => this.nomalizeFilename(path.join(path.dirname(filename), i.n || ''))).filter(Boolean);\n        return ret\n    }\n\n    async buildImportGraph(filename: string) {\n        filename = this.nomalizeFilename(filename)\n        let mod = this.fileToModuleMap.get(filename)\n        if (!mod) {\n            mod = new ModuleNode()\n\n            const importedFileNames = await this.getImportedFileNames(filename)\n            importedFileNames.forEach(async (importedFileName) => {\n                if (importedFileName !== EMPTY_PATH) {\n                    const dep = await this.buildImportGraph(importedFileName)\n                    mod!.importedModules.add(importedFileName)\n                    dep.importers.add(filename)\n                }\n            })\n\n            this.fileToModuleMap.set(filename, mod)\n        }\n\n        return mod\n    }\n    nomalizeFilename(filename: string) {\n        if (bareImportRE.test(filename)) {\n            filename = this.resolveUrl(filename)\n        }\n\n        if (!fs.existsSync(filename)) {\n            if (fs.existsSync(filename + '.ts')) {\n                filename = filename + '.ts'\n            }\n\n            if (fs.existsSync(filename + '.tsx')) {\n                filename = filename + '.tsx'\n            }\n        }\n\n        if (filename.endsWith('.ts') || filename.endsWith('.tsx')) {\n            return filename\n        } else {\n            return EMPTY_PATH\n        }\n    }\n\n    async handleModuleChange(moduleName: string) {\n        moduleName = this.nomalizeFilename(moduleName)\n        const importedFileNames = await this.getImportedFileNames(moduleName)\n        const mod = this.fileToModuleMap.get(moduleName)\n\n        if (mod) {\n            for (let importedFileName of importedFileNames) {\n                // 当前文件新增了模块\n                if (!mod.importedModules.has(importedFileName)) {\n                    const dep = await this.buildImportGraph(importedFileName)\n                    mod.importedModules.add(importedFileName)\n                    dep.importers.add(moduleName)\n                }\n            }\n\n            for (let importedFileName of mod.importedModules) {\n                // 当前文件删除了模块\n                if (!importedFileNames.includes(importedFileName)) {\n                    const dep = this.fileToModuleMap.get(importedFileName)\n                    mod.importedModules.delete(importedFileName)\n\n                    if (dep) {\n                        dep.importers.delete(moduleName)\n                        if (dep.importers.size === 0 && !this.entrys.has(importedFileName)) {\n                            this.cleanFileToModuleMap(importedFileName)\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    cleanFileToModuleMap(name: string) {\n        const importedModules = this.fileToModuleMap.get(name)!.importedModules\n\n        for (let importedModule of importedModules) {\n            const dep = this.fileToModuleMap.get(importedModule)\n            if (dep) {\n                dep.importers.delete(name)\n                if (dep.importers.size === 0) {\n                    this.cleanFileToModuleMap(importedModule)\n                }\n            }\n        }\n\n        this.fileToModuleMap.delete(name)\n    }\n\n    resolveUrl(url: string) {\n        return resolveUrl(url, this.alias)\n    }\n\n    getUpdateFilesByModuleName(moduleName: string) {\n        const needUpdateFiles = new Set<string>()\n\n        if (!this.fileToModuleMap.has(moduleName)) {\n            return needUpdateFiles\n        }\n\n        getUpdateFilesByModuleNameImpl(\n            moduleName,\n            this.entrys,\n            this.fileToModuleMap,\n            needUpdateFiles,\n            []\n        )\n        return needUpdateFiles\n    }\n}\n\nfunction getUpdateFilesByModuleNameImpl(\n    moduleName: string,\n    entrys: Set<string>,\n    fileToModuleMap: Map<string, ModuleNode>,\n    needUpdateFiles: Set<string>,\n    currentChain: string[]\n) {\n    if (entrys.has(moduleName)) { // 到顶部了\n        needUpdateFiles.add(moduleName)\n    } else {\n        const module = fileToModuleMap.get(moduleName)\n        if (module) {\n            for (let importer of module.importers) {\n                const subChain = [...currentChain, importer]\n                if (!currentChain.includes(importer)) {\n                    getUpdateFilesByModuleNameImpl(importer, entrys, fileToModuleMap, needUpdateFiles, subChain)\n                }\n            }\n        }\n    }\n}\n\nexport function resolveUrl(url: string, alias: Record<string, string>) {\n    for (let [key, value] of Object.entries(alias)) {\n        if (url.startsWith(key)) {\n            return url.replace(key, value)\n        }\n    }\n\n    return EMPTY_PATH\n}\n"],"mappings":"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","names":[]}